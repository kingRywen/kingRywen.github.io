<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>webpack</title>
    <url>/2019/10/23/webpack/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个<strong>依赖图(dependency graph)</strong>，此依赖图会映射项目所需的每个模块，并生成一个或多个 bundle。</p>
</blockquote>
<p>上面一段话摘自官方文档，由此引申出下面几个问题</p>
<ol>
<li>什么是依赖图？依赖图是怎么映射项目所需的模块？</li>
<li>bundle 是什么？</li>
</ol>
<a id="more"></a>
<h3 id="依赖图"><a href="#依赖图" class="headerlink" title="依赖图"></a>依赖图</h3><p>webpack 开箱即用，可以无需使用任何配置文件。然而，webpack 会假定项目的入口起点为工程目录 <code>src/index</code>，然后会在 <code>dist/main.js</code> 输出结果，并且在生产环境开启压缩和优化。</p>
<p>也就是说，在没有任何配置文件和命令行传参的情况下，会有一个默认的入口起点 <code>src/index</code> (如果自己配置了入口就会使用配置好的)，直接执行</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">webpack</span><br></pre></td></tr></table></figure>
<p>webpack 会将 <code>mode</code> 的默认值设置为 <code>production</code>并开始打包，从 入口起点 开始，webpack 递归地构建一个依赖图，这个依赖图包含着应用程序所需的每个模块，然后将所有这些模块打包为少量的 bundle - 通常只有一个 - 可由浏览器加载。</p>
<p>所以依赖图的生成是首先取决于入口文件，当然，在入口文件中如果也引入了其它文件，那么其它文件也会变成依赖图一部分。</p>
<h3 id="bundle"><a href="#bundle" class="headerlink" title="bundle"></a>bundle</h3><p>bundle 就是 webpack 生成的文件，bundle 里包含多个 chunk - 代码块，可能多个 bundle 会存在相同的代码块，所以需要用代码分离来共享相同代码块部分</p>
<h3 id="process-env-NODE-ENV"><a href="#process-env-NODE-ENV" class="headerlink" title="process.env.NODE_ENV"></a>process.env.NODE_ENV</h3><p>在 wepback4 中，存在两种模式，<code>development</code>、<code>production</code>，webpack 自动会引入<code>definePlugin</code>，这个插件会决定在开发环境与生产环境(dev-vs-prod)下，server tools(服务期工具)、build scripts(构建脚本) 和 client-side libraries(客户端库) <code>process.env.NODE_ENV</code>的值，然而，在 <code>webpack.config.js</code> 中是不会存在这个值的，要在配置文件中使用<code>process.env.NODE_ENV</code>，有以下两种方法</p>
<ul>
<li>命令行中传入<code>--env.NODE_ENV production|development</code>， <code>webpack.config.js</code> 中导出函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="params">env</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(env.NODE_ENV); <span class="comment">// production|development</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>cross-env</code>传参</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装cross-env</span></span><br><span class="line">yarn add -D cross-env</span><br><span class="line"></span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line">cross-env NODE_ENV=production webpack ./webpack.config.js</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(process.env.NODE_ENV) <span class="comment">// production|development</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口 entry"></a>入口 entry</h2><p>入口的写法，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// normal</span></span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span></span><br><span class="line">  <span class="comment">// 对象语法</span></span><br><span class="line">  <span class="comment">// 使用 optimization.splitChunks 为页面间共享的应用程序代码创建 bundle。</span></span><br><span class="line">  <span class="comment">// 由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块</span></span><br><span class="line">  <span class="comment">// 如果输出为library 可以使用 array 语法暴露所有模块</span></span><br><span class="line">  <span class="comment">// 参考 https://github.com/webpack/webpack/tree/master/examples/multi-part-library</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./path/to/my/entry/file.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 数组</span></span><br><span class="line">  <span class="comment">// 这样传会合并多个文件为一个bundle文件</span></span><br><span class="line">  <span class="comment">// 如果输出为library时只会暴露最后一个模块</span></span><br><span class="line">  entry: [<span class="string">'path1'</span>, <span class="string">'path2'</span>]</span><br><span class="line">  <span class="comment">// 动态入口 可以接收远程服务器的数据来决定入口，感觉没什么用</span></span><br><span class="line">  entry: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'./demo'</span></span><br><span class="line">  <span class="comment">// 或</span></span><br><span class="line">  entry: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve([<span class="string">'./demo'</span>, <span class="string">'./demo2'</span>]))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="输出-output"><a href="#输出-output" class="headerlink" title="输出 output"></a>输出 output</h2><p>输出主要是告诉 webpack 打包后的 bundle 放在哪里，以及如何命名这些文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// normal</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>), <span class="comment">// 打包后的目录 URL以HTML页面为基准</span></span><br><span class="line">    filename: <span class="string">"my-first-webpack.bundle.js"</span>, <span class="comment">// 文件命名</span></span><br><span class="line">    publicPath: <span class="string">"assets/"</span>, <span class="comment">// 相对于 html 页面</span></span><br><span class="line">    publicPath: <span class="string">"/assets/"</span> <span class="comment">// 相对于服务器根目录</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 多个入口起点 使用占位符</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"[name].js"</span></span><br><span class="line">    <span class="comment">// 输出文件 ./dist/name1.js  ./dist/name2.js</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// cdn hash</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: <span class="string">"/home/proj/cdn/assets/[hash]"</span>, <span class="comment">// 此处打包后会生成到硬盘根路径</span></span><br><span class="line">    publicPath: <span class="string">"http://cdn.example.com/assets/[hash]/"</span> <span class="comment">// cdn路径</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="在运行时设置-publicPath"><a href="#在运行时设置-publicPath" class="headerlink" title="在运行时设置 publicPath"></a>在运行时设置 publicPath</h3><p>所谓运行时，即在打包完成后运行应用程序的时候。一般在 output 中配置的 publicPath 是固定的，但是，我们可能需要在运行的时候动态加载 publicPath,webpack 暴露了一个名为 <strong>webpack_public_path</strong> 的全局变量，通过改变这个变量的值达到我们的目的。</p>
<ol>
<li>创建一个文件<code>public_path.js</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">__webpack_public_path__ = <span class="string">"http://some.cdn.com/some"</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在入口文件中引入</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"public_path.js"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./app.js"</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果在 entry 文件中使用 ES2015 module import，则会在 import 之后进行 <strong>webpack_public_path</strong> 赋值。在这种情况下，你必须将 public path 赋值移至一个专用模块中，然后将它的 import 语句放置到 entry.js 最上面</p>
</blockquote>
<h3 id="chunkFilename"><a href="#chunkFilename" class="headerlink" title="chunkFilename"></a>chunkFilename</h3><p>定义非入口 chunk 文件的名称。这个在动态导入时可以设置分出来的文件名</p>
<p>如下，在文件中使用 import()时，webpack 会在打包时将 a.js 分离出去，成为一个新的文件，这个文件在没有设置 chunkFilename 时会自动使用<code>[模块id].js</code>命名(如果注释名存在则使用注释名), 当然，使用注释命名也可以</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">'./a.js'</span>) <span class="comment">// 输出文件 0.js</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "chunk1" */</span><span class="string">'./a.js'</span>) <span class="comment">// 输出文件 chunk1.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置chunkFilename后</span></span><br><span class="line">output: &#123;</span><br><span class="line">  chunkFilename: <span class="string">'[name].[chunkhash].js'</span> <span class="comment">// name 一般是模块id 如果有注释名则使用注释名</span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 0.[chunkhash].js</span></span><br><span class="line"><span class="comment">// chunk1.[chunkhash].js</span></span><br></pre></td></tr></table></figure>
<h3 id="crossOriginLoading-jsonpScriptType-chunkLoadTimeout"><a href="#crossOriginLoading-jsonpScriptType-chunkLoadTimeout" class="headerlink" title="crossOriginLoading | jsonpScriptType | chunkLoadTimeout"></a>crossOriginLoading | jsonpScriptType | chunkLoadTimeout</h3><p>crossOriginLoading，只用于 <code>target</code> 是 <code>web</code>，使用了通过 script 标签的 JSONP 来按需加载 chunk。通过加载资源的 origin 信息来判断是否跨域，比如在 cdn 加载 chunk 的时候肯定是跨域的，那么此设置就会生效</p>
<p>jsonpScriptType 设置 jsonp 中 script 的 type 属性</p>
<p>chunkLoadTimeout 设置 script 中超时时间，默认 120s</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (script.src.indexOf(<span class="built_in">window</span>.location.origin + <span class="string">"/"</span>) !== <span class="number">0</span>) &#123;</span><br><span class="line">  script.crossOrigin = <span class="string">"anonymous"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="filename-中的-chunkhash-contenthash"><a href="#filename-中的-chunkhash-contenthash" class="headerlink" title="filename 中的 chunkhash contenthash"></a>filename 中的 chunkhash contenthash</h3><p>chunkhash 和 contenthash 的区别在于，都是 chunk 内容，不过 contenthash 是通过<code>ExtractTextWebpackPlugin</code>提取出来的，如果 js 文件改变打包后 css 内容即使没变 css hash 也会改变</p>
<h3 id="libraryTarget"><a href="#libraryTarget" class="headerlink" title="libraryTarget"></a>libraryTarget</h3><p>配置如何暴露 library。</p>
<ol>
<li><strong>var</strong>. （默认值）当 library 加载完成，入口起点的返回值将分配给 library 变量，会覆盖掉已经定义过的全局变量（谨慎使用）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">output.library = <span class="string">"someLibName"</span>;</span><br><span class="line"><span class="comment">// 打包后，加载完库后会把库对象分配给全局变量 someLibName</span></span><br><span class="line"><span class="keyword">var</span> someLibName = <span class="built_in">module</span>.exports; <span class="comment">// 输出结果，如果在之前存在全局变量someLibName会覆盖</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>assign</strong>. 比 <code>&#39;var&#39;</code>少了个 var，可以说没区别</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">someLibName = <span class="built_in">module</span>.exports; <span class="comment">// 输出结果</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>this</strong>.</li>
</ol>
<ul>
<li>output.library 没有赋值，webpack 将把 library 对象上所有的属性挂载到浏览器的 this 上，也就是 window</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">e, a</span>) </span>&#123; <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> a) e[i] = a[i]; &#125;(<span class="keyword">this</span>, <span class="built_in">module</span>.exports)</span><br><span class="line"><span class="comment">// 遍历exports对象并挂载到this</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>output.library = &#39;someLibName&#39;</code>则会将对象挂载到<code>this[&#39;someLibName&#39;]</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>[<span class="string">"someLibName"</span>] = <span class="built_in">module</span>.exports;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><strong>window</strong> 同上</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>[<span class="string">"someLibName"</span>] = <span class="built_in">module</span>.exports;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><strong>global</strong> 分配给 global 对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">global[<span class="string">"someLibName"</span>] = <span class="built_in">module</span>.exports;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li><strong>commonjs</strong> 分配给 exports 对象。这个名称也意味着，模块用于 CommonJS 环境</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports[<span class="string">"someLibName"</span>] = <span class="built_in">module</span>.exports;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"someLibName"</span>).doSomething();</span><br></pre></td></tr></table></figure>
<ol start="7">
<li><strong>commonjs2</strong> 模块定义系统.用于<code>CommonJS</code>系统，入口起点的返回值将分配给 <code>module.exports</code> 对象</li>
</ol>
<p>与<code>commonjs</code>的区别是不用指定 output.library</p>
<blockquote>
<p>模块定义系统会使 <code>bundle</code> 带有更多的头部处理，以便兼容各种模块系统</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = _entry_return_;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"MyLibrary"</span>).doSomething();</span><br></pre></td></tr></table></figure>
<ol start="8">
<li><strong>amd</strong> 将 library 导出为 AMD 模块</li>
</ol>
<p>可以由 RequireJS 或任何兼容的模块加载器加载。直接加载会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyLibrary.js</span></span><br><span class="line">define(<span class="string">"MyLibrary"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _entry_return_;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器 使用前需要先引入RequireJS</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">"MyLibrary"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">MyLibrary</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 library 做一些事……</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="9">
<li><strong>umd</strong> 将 library 导出为所有的模块定义下都可运行的方式。既可以在 CommonJS, AMD 环境下运行，也可以在浏览器环境下且无需 requireJS 的情况下运行。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack配置</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    library: <span class="string">"MyLibrary"</span>, <span class="comment">// 如果不设置的话，webpack会把exports对象上的所有属性挂载到全局变量上</span></span><br><span class="line">    libraryTarget: <span class="string">"umd"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 也可以给每个导出环境配置不同的名称</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    library: &#123;</span><br><span class="line">      root: <span class="string">"MyLibrary"</span>,</span><br><span class="line">      amd: <span class="string">"my-library"</span>,</span><br><span class="line">      commonjs: <span class="string">"my-common-library"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    libraryTarget: <span class="string">"umd"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyLibrary.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">webpackUniversalModuleDefinition</span>(<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span>)</span><br><span class="line">    <span class="built_in">module</span>.exports = factory();</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd) define([], factory);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">"object"</span>) exports[<span class="string">"MyLibrary"</span>] = factory();</span><br><span class="line">  <span class="keyword">else</span> root[<span class="string">"MyLibrary"</span>] = factory();</span><br><span class="line">&#125;)(<span class="keyword">typeof</span> self !== <span class="string">"undefined"</span> ? self : <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _entry_return_; <span class="comment">// 此模块返回值，是入口 chunk 返回的值</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="10">
<li><strong>jsonp</strong> 将导出结果包裹在以 library 变量作为函数名的容器中</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">library: <span class="string">"MyLibrary"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyLibrary.js</span></span><br><span class="line">MyLibrary(_entry_return_);</span><br></pre></td></tr></table></figure>
<h3 id="exports、module-exports-和-export、export-default"><a href="#exports、module-exports-和-export、export-default" class="headerlink" title="exports、module.exports 和 export、export default"></a>exports、module.exports 和 export、export default</h3><blockquote>
<p>require: node 和 es6 都支持的引入<br>export / import : 只有 es6 支持的导出引入<br>module.exports / exports: 只有 node 支持的导出</p>
</blockquote>
<h4 id="node-模块"><a href="#node-模块" class="headerlink" title="node 模块"></a>node 模块</h4><ul>
<li>commonjs 导入导出 nodejs 支持，浏览器不支持（引用 requirejs 也可以支持）。<strong>在 webpack 打包时，如果使用了 module.exports 作为最终输出时，在浏览器中运行是获取不到模块中的变量的</strong></li>
</ul>
<p>Node 里面的模块系统遵循的是 CommonJS 规范。CommonJS 定义的模块分为: 模块标识(module)、模块定义(exports) 、模块引用(require)。<br>当 Node 执行一个文件时，会为文件生成一个 exports 和 module 对象，而 module 对象的 exports 属性和 exports 指向同一个内存地址。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports = <span class="built_in">module</span>.exports = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>当 Node 导入某个文件模块时，实际上是导入文件的 module.exports 属性。重新给 exports 属性赋一个对象会导致 exports 属性与 module.exports 断开连接。</p>
<ul>
<li>es6 导入导出 主要用于浏览器加载模块，当然 nodejs 也支持<ol>
<li>export 与 export default 均可用于导出常量、函数、文件、模块等</li>
<li>在一个文件或模块中，export、import 可以有多个，export default 仅有一个</li>
<li>通过 export 方式导出，在导入时要加{ }，export default 则不需要</li>
<li>export 能直接导出变量表达式，export default 不行。</li>
</ol>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// testEs6Export.js</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="comment">//导出变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="string">"100"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> dogSay = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"wang wang"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出方法第二种</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">catSay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"miao miao"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; catSay &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export default导出</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> m;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; dogSay, catSay &#125; <span class="keyword">from</span> <span class="string">"./testEs6Export"</span>; <span class="comment">//导出了 export 方法</span></span><br><span class="line"><span class="keyword">import</span> m <span class="keyword">from</span> <span class="string">"./testEs6Export"</span>; <span class="comment">//导出了 export default</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> testModule <span class="keyword">from</span> <span class="string">"./testEs6Export"</span>; <span class="comment">//as 集合成对象导出</span></span><br><span class="line"><span class="built_in">console</span>.log(testModule.m); <span class="comment">// undefined , 因为  as 导出是 把 零散的 export 聚集在一起作为一个对象，而export default 是导出为 default属性。</span></span><br><span class="line"><span class="built_in">console</span>.log(testModule.default); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<h4 id="commonjs-vs-commonjs2"><a href="#commonjs-vs-commonjs2" class="headerlink" title="commonjs vs commonjs2"></a>commonjs vs commonjs2</h4><p>那么 webpack 打包 library 时 commonjs 与 commonjs2 的区别就是 commonjs 必须赋值一个变量作为 exports 的属性，commonjs2 则是直接导出为 <code>module.exports</code> 的对象</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>利用缓存技术可以合理利用浏览器缓存减少请求，加快网站的加载速度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 改为contenthash 通过内容来映射hash,内容变化则hash变，内容不变hash不变</span></span><br><span class="line">    filename: <span class="string">"[name].[contenthash].js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    <span class="comment">// 分离runtime</span></span><br><span class="line">    runtimeChunk: <span class="string">"single"</span>,</span><br><span class="line">    <span class="comment">// 将第三方库提取到单独的vendor文件中</span></span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          name: <span class="string">"vendors"</span>,</span><br><span class="line">          chunks: <span class="string">"all"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> webpack.HashedModuleIdsPlugin() <span class="comment">// 保持内容不变的情况下hash也不变</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="output-umdNamedDefine"><a href="#output-umdNamedDefine" class="headerlink" title="output.umdNamedDefine"></a>output.umdNamedDefine</h3><p>当使用了 <code>libraryTarget: &quot;umd&quot;</code>，设置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    umdNamedDefine: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包后</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd)</span><br><span class="line">  define(<span class="string">"someLibName"</span> <span class="comment">/*这里会加上library字段的值*/</span>, [], factory);</span><br></pre></td></tr></table></figure>
<h3 id="output-pathinfo"><a href="#output-pathinfo" class="headerlink" title="output.pathinfo"></a>output.pathinfo</h3><p>开启后多了下面的注释部分，会导致造成垃圾回收性能压力，建议还是关闭</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***/</span> <span class="string">"tjUo"</span>:</span><br><span class="line"><span class="comment">/*!**********************!*\</span></span><br><span class="line"><span class="comment">  !*** ./src/index.js ***!</span></span><br><span class="line"><span class="comment">  \**********************/</span></span><br><span class="line"><span class="comment">/*! exports provided: a */</span></span><br><span class="line"><span class="comment">/***/</span></span><br></pre></td></tr></table></figure>
<h2 id="模式-mode"><a href="#模式-mode" class="headerlink" title="模式 mode"></a>模式 mode</h2><blockquote>
<p>值有：<code>none</code>, <code>development</code>, <code>production</code>（默认）。设置 <code>NODE_ENV</code> 并不会自动地设置 mode。</p>
</blockquote>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置文件</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cli传参</span></span><br><span class="line">webpack --mode=development</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>development</td>
<td style="text-align:left">会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。</td>
</tr>
<tr>
<td>production</td>
<td style="text-align:left">会将 DefinePlugin 中 process.env.NODE_ENV 的值设置为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 TerserPlugin。</td>
</tr>
<tr>
<td>none</td>
<td style="text-align:left">退出任何默认优化选项.</td>
</tr>
</tbody>
</table>
<h4 id="mode-development"><a href="#mode-development" class="headerlink" title="mode: development"></a><code>mode: development</code></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.development.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">+ mode: <span class="string">'development'</span></span><br><span class="line">- devtool: <span class="string">'eval'</span>,</span><br><span class="line">- cache: <span class="literal">true</span>, <span class="comment">// 缓存生成的 webpack 模块和 chunk，来改善构建速度。缓存默认在观察模式(watch mode)启用</span></span><br><span class="line">- performance: &#123;</span><br><span class="line">-   hints: <span class="literal">false</span> <span class="comment">// false | "error" | "warning" 是否开启打包后文件过大的性能提示 false不开启，warning 展示警告 error展示错误(开发环境中会展示在浏览器的工作台中)。文件大小可以限制可以自由配置</span></span><br><span class="line">- &#125;,</span><br><span class="line">- output: &#123;</span><br><span class="line">-   pathinfo: <span class="literal">true</span></span><br><span class="line">- &#125;,</span><br><span class="line">- optimization: &#123;</span><br><span class="line">-   namedModules: <span class="literal">true</span>,</span><br><span class="line">-   namedChunks: <span class="literal">true</span>,</span><br><span class="line">-   nodeEnv: <span class="string">'development'</span>,</span><br><span class="line">-   flagIncludedChunks: <span class="literal">false</span>,</span><br><span class="line">-   occurrenceOrder: <span class="literal">false</span>,</span><br><span class="line">-   sideEffects: <span class="literal">false</span>,</span><br><span class="line">-   usedExports: <span class="literal">false</span>,</span><br><span class="line">-   concatenateModules: <span class="literal">false</span>,</span><br><span class="line">-   splitChunks: &#123;</span><br><span class="line">-     hidePathInfo: <span class="literal">false</span>,</span><br><span class="line">-     minSize: <span class="number">10000</span>,</span><br><span class="line">-     maxAsyncRequests: <span class="literal">Infinity</span>,</span><br><span class="line">-     maxInitialRequests: <span class="literal">Infinity</span>,</span><br><span class="line">-   &#125;,</span><br><span class="line">-   noEmitOnErrors: <span class="literal">false</span>,  <span class="comment">// 设置为true 则会在编译出错时跳过生成阶段，避免生成错误打包文件</span></span><br><span class="line">-   checkWasmTypes: <span class="literal">false</span>,</span><br><span class="line">-   minimize: <span class="literal">false</span>,</span><br><span class="line">- &#125;,</span><br><span class="line">- plugins: [</span><br><span class="line">-   <span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">-   <span class="keyword">new</span> webpack.NamedChunksPlugin(),</span><br><span class="line">-   <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="string">"process.env.NODE_ENV"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"development"</span>) &#125;),</span><br><span class="line">- ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h2><p>webpack 4 特有的优化选项，可以进行压缩代码，分包等操作</p>
<h3 id="minimize"><a href="#minimize" class="headerlink" title="minimize"></a>minimize</h3><p>开启后使用<a href="https://webpack.docschina.org/plugins/terser-webpack-plugin/" target="_blank" rel="noopener">TerserPlugin</a>压缩。<code>mode:production</code>时自动开启</p>
<h3 id="minimizer"><a href="#minimizer" class="headerlink" title="minimizer"></a>minimizer</h3><p>测试后只在<code>mode: production</code>时有效，可以配置 terserPlugin 的参数</p>
<h3 id="splitChunks"><a href="#splitChunks" class="headerlink" title="splitChunks"></a>splitChunks</h3><p>用于分割代码块，提取出公用代码块。在多页面项目或者动态导入模块的时候非常有用，能减少初始加载代码的大小，提升网页首屏的加载速度。</p>
<p><code>splitChunks</code>默认只影响按需块，当然也可以通过设置 <code>chunks: &#39;initial&#39;</code>来拆分公用初始代码块。</p>
<blockquote>
<p><code>splitChunks</code> 总是会提取按需块</p>
</blockquote>
<p>先看看 webpack 中默认的<code>splitChunks</code>设置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      <span class="comment">// 可设置的值有 initial, async, all</span></span><br><span class="line">      <span class="comment">// all 最佳配置，当分离的块既有同步又有按需引入时，共享代码</span></span><br><span class="line">      <span class="comment">// initial 当分离的块既有同步又有按需引入时，不共享代码</span></span><br><span class="line">      <span class="comment">// async 只拆分按需引入块</span></span><br><span class="line">      chunks: <span class="string">"async"</span>,</span><br><span class="line">      <span class="comment">// 当代码块大于这个值的时候就会被拆分出来</span></span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      <span class="comment">// 当代码块大于这个值的时候会继续拆分（如果还可以拆分的话） 0表示不拆分</span></span><br><span class="line">      maxSize: <span class="number">0</span>,</span><br><span class="line">      <span class="comment">// 当代码块被引用的次数超过这个数的时候才会拆分</span></span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      <span class="comment">// 最多能拆分的按需块 &gt;= 1</span></span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">      <span class="comment">// 最多能拆分的初始块 &gt;= 1  如果设置了maxSize，并且能拆分，可能会拆分出更多的块</span></span><br><span class="line">      maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">      <span class="comment">// 块文件名分隔符</span></span><br><span class="line">      automaticNameDelimiter: <span class="string">"~"</span>,</span><br><span class="line">      <span class="comment">// 分割块的名字。如果传入 true 将会自动生成一个基于块组和缓存组键的名称</span></span><br><span class="line">      <span class="comment">// 也可以用函数生成名称</span></span><br><span class="line">      <span class="comment">// name (module, chunks, cacheGroupKey) &#123;</span></span><br><span class="line">      <span class="comment">//   // generate a chunk name...</span></span><br><span class="line">      <span class="comment">//   return; //...</span></span><br><span class="line">      <span class="comment">// &#125;,</span></span><br><span class="line">      name: <span class="literal">true</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          priority: <span class="number">-10</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="多页面分割代码"><a href="#多页面分割代码" class="headerlink" title="多页面分割代码"></a>多页面分割代码</h4><p><a href="https://github.com/kingRywen/webpack-test/tree/splitChunk" target="_blank" rel="noopener">栗子地址</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> entry = &#123;</span><br><span class="line">  <span class="comment">// 多个入口</span></span><br><span class="line">  index: <span class="string">"./src/index.js"</span>,</span><br><span class="line">  pageA: <span class="string">"./src/a.js"</span>,</span><br><span class="line">  pageB: <span class="string">"./src/b.js"</span>,</span><br><span class="line">  pageC: <span class="string">"./src/c.js"</span>,</span><br><span class="line">  pageD: <span class="string">"./src/d.js"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> _chunks = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加分离出来的runtime和node_modules中的库，以及当前页的chunk到chunk映射变量_chunks中</span></span><br><span class="line"><span class="built_in">Object</span>.keys(entry).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  _chunks[key] = [key, <span class="string">"runtime"</span>, <span class="string">"vendors"</span>];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> htmls = <span class="built_in">Object</span>.keys(entry).map(</span><br><span class="line">  name =&gt;</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: name + <span class="string">".html"</span>,</span><br><span class="line">      template: <span class="string">"template.pug"</span>,</span><br><span class="line">      title: name,</span><br><span class="line">      chunks: _chunks[name]</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">"production"</span>,</span><br><span class="line">  entry,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">    crossOriginLoading: <span class="string">"anonymous"</span>,</span><br><span class="line">    filename: <span class="string">"[name].[contenthash].js"</span>,</span><br><span class="line">    pathinfo: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  performance: &#123;</span><br><span class="line">    hints: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: <span class="literal">true</span>,</span><br><span class="line">    runtimeChunk: <span class="string">"single"</span>,</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">"all"</span>,</span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      maxSize: <span class="number">0</span>,</span><br><span class="line">      minChunks: <span class="number">2</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">20</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">20</span>,</span><br><span class="line">      automaticNameDelimiter: <span class="string">"~"</span>,</span><br><span class="line">      <span class="comment">// 关键命名函数，将引入次数2次以上的公共业务代码分割出来，并命名</span></span><br><span class="line">      <span class="comment">// 命名的同时将chunk推入_chunks中，改变入口htmlwebpack中chunks的引入</span></span><br><span class="line">      name(<span class="built_in">module</span>, chunks, cacheGroupKey) &#123;</span><br><span class="line">        <span class="keyword">let</span> name = chunks.map(<span class="function"><span class="params">el</span> =&gt;</span> el.name).join(<span class="string">"~"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; chunks.length; index++) &#123;</span><br><span class="line">          <span class="keyword">const</span> c = chunks[index];</span><br><span class="line">          <span class="keyword">if</span> (c.name &amp;&amp; _chunks[c.name] &amp;&amp; !~_chunks[c.name].indexOf(name)) &#123;</span><br><span class="line">            _chunks[c.name].push(name);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">      &#125;,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        <span class="comment">// 分割库代码</span></span><br><span class="line">        commons: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          name: <span class="string">"vendors"</span>,</span><br><span class="line">          chunks: <span class="string">"all"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="模块-module"><a href="#模块-module" class="headerlink" title="模块(module)"></a>模块(module)</h3><p>webpack 模块是管理各种文件资源的途径，通过 loader 能解析非.js 文件</p>
<h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><h5 id="普通-css"><a href="#普通-css" class="headerlink" title="普通 css"></a>普通 css</h5><p>通过<code>import &#39;./style.css&#39;</code>方法引入样式文件，在没有配置 module 的情况下 webpack 是不会正常解析 css 文件的，所以我们必须引入<code>style-loader</code>来将引入的 css 文件解析出来。当然也要引入<code>css-loader</code>来解析 css 文件的内容,css-loader 也能解析 css 中的引入：<code>@import</code>及<code>url()</code>（可以配置不解析某些资源）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">yarn add -D style-loader</span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// 区分生产环境和开发环境,生产环境时提取css作为单独文件</span></span><br><span class="line">          process.env.NODE_ENV == <span class="string">'production'</span> ? MiniCssExtractPlugin.loader : <span class="string">'style-loader'</span>, &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">              modules: <span class="literal">true</span>, <span class="comment">// css 模块化</span></span><br><span class="line">              sourceMap: <span class="literal">true</span> <span class="comment">// 开启 sourceMap</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="sass"><a href="#sass" class="headerlink" title="sass"></a>sass</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">yarn add sass-loader node-sass -D</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          process.env.NODE_ENV == <span class="string">'production'</span> ? MiniCssExtractPlugin.loader : <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">'sass-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#####　 postcss</p>
<p>在<a href="http://postcss.org/" target="_blank" rel="noopener">PostCSS</a>官网有着这样的对 PostCSS 特性介绍，箭头后面是对应功能的插件及其 github 地址。</p>
<ol>
<li>increase code readability （增加代码可读性，补全） → <a href="https://github.com/postcss/autoprefixer" target="_blank" rel="noopener">Autoprefixer</a></li>
<li>Use tomorrow’s CSS ,today!（使用下代 css） → <a href="https://github.com/MoOx/postcss-cssnext/" target="_blank" rel="noopener">postcss-cssnext</a></li>
<li>The end of global CSS（模块化 css）→ <a href="https://github.com/css-modules/postcss-modules" target="_blank" rel="noopener">postcss-modules</a></li>
<li>Avoid errors in your CSS（错误提示） → <a href="https://github.com/stylelint/stylelint" target="_blank" rel="noopener">stylelint</a></li>
<li>Powerful grid CSS（栅格系统） → lost →<a href="https://github.com/peterramsing/lost" target="_blank" rel="noopener">lost</a></li>
</ol>
<h5 id="webpack-中使用-postcss"><a href="#webpack-中使用-postcss" class="headerlink" title="webpack 中使用 postcss"></a>webpack 中使用 postcss</h5><p><code>PostCSS Preset Env</code>可以将现代 CSS 转换为大多数浏览器可以理解的内容，并根据目标浏览器或运行时环境确定所需的 polyfill。</p>
<p>启用 sourceMap 支持，postcss-loader 将使用其他加载器提供的先前的 sourceMap 并进行相应的更新。除<code>style-loader</code>之外的 loader 都需要配置<code>sourceMap: true</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">yarn add -D postcss-preset-env</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">      <span class="string">'style-loader'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">"css-loader"</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          sourceMap: <span class="literal">true</span>,</span><br><span class="line">          <span class="comment">// 必须配置，影响@import导入的文件中的加载器的数量，</span></span><br><span class="line">          <span class="comment">// 如果不配置@import导入文件将不会应用后面的加载器</span></span><br><span class="line">          importLoaders: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          sourceMap: <span class="literal">true</span>,</span><br><span class="line">          indent: <span class="string">'postcss'</span>,</span><br><span class="line">          plugins: <span class="function"><span class="params">()</span> =&gt;</span> [</span><br><span class="line">            <span class="comment">// 使用 PostCSS Preset Env</span></span><br><span class="line">            <span class="comment">// postcss-preset-env已经预置autoprefixer，无需单独添加它</span></span><br><span class="line">            postcssPresetEnv(&#123;</span><br><span class="line">              stage: <span class="number">3</span>,</span><br><span class="line">              <span class="comment">// 支持任何标准的browserslist配置，可以是.browserslistrc文件，package.json中的browserslist或browserslist环境变量。</span></span><br><span class="line">              browsers: <span class="string">'last 2 versions'</span></span><br><span class="line">            &#125;)</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="images-图像"><a href="#images-图像" class="headerlink" title="images 图像"></a>images 图像</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">yarn add -D url-loader</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">        <span class="comment">// url-loader将少于limit的图像文件转化为dataUrl来减少请求</span></span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          <span class="comment">// 当图像大于limit时，会使用备用的loader</span></span><br><span class="line">          fallback: &#123;</span><br><span class="line">            loader: <span class="string">'file-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              name: <span class="string">'img/[name].[hash:8].[ext]'</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          limit: <span class="number">4096</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fonts-字体"><a href="#fonts-字体" class="headerlink" title="fonts 字体"></a>fonts 字体</h4><p><code>file-loader</code> 和 <code>url-loader</code> 可以接收并加载任何文件，所以也可以用来加载 fonts 字体文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(woff|woff2|eot|ttf|otf)$/</span>,</span><br><span class="line">        loader: <span class="string">"url-loader"</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          fallback: &#123;</span><br><span class="line">            loader: <span class="string">"file-loader"</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              name: <span class="string">"img/[name].[hash:8].[ext]"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          limit: <span class="number">4096</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="数据-json-xml"><a href="#数据-json-xml" class="headerlink" title="数据 json xml"></a>数据 json xml</h4><p>加载的资源还有数据，如 JSON 文件，CSV、TSV 和 XML。类似于 NodeJS，JSON 支持实际上是内置的，也就是说 <code>import Data from &#39;./data.json&#39;</code> 默认将正常运行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+       &#123;</span><br><span class="line">+         test: <span class="regexp">/\.(csv|tsv)$/</span>,</span><br><span class="line">+         use: [</span><br><span class="line">+           <span class="string">'csv-loader'</span></span><br><span class="line">+         ]</span><br><span class="line">+       &#125;,</span><br><span class="line">+       &#123;</span><br><span class="line">+         test: <span class="regexp">/\.xml$/</span>,</span><br><span class="line">+         use: [</span><br><span class="line">+           <span class="string">'xml-loader'</span></span><br><span class="line">+         ]</span><br><span class="line">+       &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序配置本地接口</title>
    <url>/2018/02/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE%E6%9C%AC%E5%9C%B0%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>之前在做公司小程序开发的时候，没有发现本地调试的方法，所以每次写完接口必须要把代码上传远程服务器进行测试，这种处理不仅不优雅，更要命的是极度拖延了开发进度，不过因为第一次接触小程序，完全不熟悉其开发原理，所以一直没有机会去改善开发逻辑。直至公司小程序开发完成后，才在网上去搜寻解决文案，终于找到本地开发调试的方法，并记录下来。<br><a id="more"></a></p>
<h1 id="安装charles"><a href="#安装charles" class="headerlink" title="安装charles"></a>安装charles</h1><p>charles是一个http代理软件(以前用过fiddle,应该类似于fiddle，不过前者功能更强大)，有windows和mac版，软件收费，基于java，所以需要电脑上装有<a href="http://www.java.com" target="_blank" rel="noopener">java</a>，所以我下载的是<a href="https://pan.baidu.com/s/1dHaY9ah" target="_blank" rel="noopener">破解版</a>(穷，有钱的可以支持一下正版)， 密码：3ghf。下载后直接解压运行。</p>
<h1 id="开始配置"><a href="#开始配置" class="headerlink" title="开始配置"></a>开始配置</h1><p>如果已经安装好了软件，那么就开始配置。</p>
<ul>
<li>首先打开Charles，安装证书到本地, 点击‘安装证书’，全点下一步，安装完成</li>
</ul>
<p><img src="http://oy9tlpm12.bkt.clouddn.com/1.png" alt></p>
<ul>
<li>打开 <code>工具-&gt;远程映射</code> 添加线上域名于本地（开发环境）服务的映射</li>
</ul>
<p><img src="http://oy9tlpm12.bkt.clouddn.com/22.png" alt></p>
<ul>
<li><p>打开 <code>代理 -&gt; 代理设置</code> 选择<code>代理</code>选项卡，默认的HTTP Proxy的值是8888，这个端口号需要记着，后边在微信web开发者工具里边要用到的</p>
</li>
<li><p>选择<code>ssl</code>选项卡,如下设置</p>
</li>
</ul>
<p><img src="http://oy9tlpm12.bkt.clouddn.com/6.png" alt></p>
<ul>
<li>选择<code>windows</code>选项卡，点击启用以下选项</li>
</ul>
<p><img src="http://oy9tlpm12.bkt.clouddn.com/3.png" alt></p>
<ul>
<li>确认 <code>工具-&gt;windows代理</code> 打上勾</li>
</ul>
<p><img src="http://oy9tlpm12.bkt.clouddn.com/4.png" alt></p>
<ul>
<li>登录微信开发者工具，选择手动设置代理，然后填写本地的IP，以及前边在Charles中设置的代理端口号。enjoy it!</li>
</ul>
]]></content>
      <tags>
        <tag>小程序</tag>
        <tag>本地调试</tag>
        <tag>charles代理</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的工具库</title>
    <url>/2018/01/26/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E5%BA%93/</url>
    <content><![CDATA[<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><ul>
<li><a href="https://greensock.com/gsap" target="_blank" rel="noopener">GreenSock | GSAP</a>: CSS动画类库</li>
<li><a href="http://robertpenner.com/easing/" target="_blank" rel="noopener">easing</a>: 函数式动画库</li>
</ul>
<a id="more"></a>
<h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><ul>
<li><a href="https://github.com/ecomfe/echarts" target="_blank" rel="noopener">Echarts</a>: 百度开发的图表库</li>
</ul>
<h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><ul>
<li><a href="http://cssreference.io/" target="_blank" rel="noopener">cssreference</a>: 一个动态展示各种CSS的学习库</li>
</ul>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>offset</title>
    <url>/2018/01/03/offset/</url>
    <content><![CDATA[<p>先来一张网上的图<br><img src="http://oy9tlpm12.bkt.clouddn.com/3131637-50e9ea1bc0764f99.png" alt></p>
<p>当然，这个图是有浏览器的兼容问题的，不是每个浏览器都是这样定义，个人觉得有两种情况，内容盒模型(标准盒模型)，边框盒模型(IE怪异盒模型)</p>
<a id="more"></a>
<h1 id="内容盒模型（标准盒模型）"><a href="#内容盒模型（标准盒模型）" class="headerlink" title="内容盒模型（标准盒模型）"></a>内容盒模型（标准盒模型）</h1><p><code>offsetWidth、offsetHeight</code>: 包含自身width、border、padding.(div.style.width 因为只能获取行内的数值)</p>
<p><code>offsetLeft、offsetTop</code>: 对于块级元素，相对最近有定位属性的父级元素（position不为默认值,可通过el.offsetParent获取）左边的距离，如果都没有定位属性则以html元素为基准。注意，在chrome、IE8中这里的比较的是父级border的外边缘与当前元素的外边缘，而firefox、IE7、IE9比较的是父级border的内边缘与当前元素的外边缘。对于可被截断到下一行的行内元素（如 span），描述的是边界框的尺寸（使用 Element.getBoundingClientRect 来获取其位置）</p>
<p><code>clientTop、clientLeft</code>: 一般返回元素的border宽度</p>
<p><code>clientWidth、clientHeight</code>: Element.clientWidth 属性表示元素的内部宽度，以像素计。该属性包括内边距，但不包括垂直滚动条（如果有）、边框和外边距。该属性值会被四舍五入为一个整数。如果你需要一个小数值，可使用 element.getBoundingClientRect()。IE7/8有点不一样<br><code>scrollWidth、scrollHeight</code>: 元素的scrollWidth只读属性以px为单位返回元素的内容区域宽度或元素的本身的宽度中更大的那个值。若元素的宽度大于其内容的区域（例如，元素存在滚动条时）, scrollWidth的值要大于clientWidth</p>
<p><code>scrollLeft、scrollTop</code>: Element.scrollLeft 属性可以读取或设置元素滚动条到元素左边的距离。也就是滚动条位置</p>
<blockquote>
<p>获取浏览器滚动条时要注意兼容：</p>
<ul>
<li>未声明 DTD 时（谷歌只认识他）<br><code>document.body.scrollTop</code></li>
<li>已经声明DTD 时（IE678只认识他）<br><code>document.documentElement.scrollTop</code></li>
<li>火狐/谷歌/ie9+以上支持的<br><code>window.pageYOffset</code></li>
</ul>
</blockquote>
<p>兼容获取浏览器滚动条</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop</span><br></pre></td></tr></table></figure>
<h1 id="边框盒模型（IE怪异盒模型）"><a href="#边框盒模型（IE怪异盒模型）" class="headerlink" title="边框盒模型（IE怪异盒模型）"></a>边框盒模型（IE怪异盒模型）</h1><p><code>offsetWidth、offsetHeight</code>: 等于自身width, width包含padding,border</p>
<p><code>offsetLeft、offsetTop</code>: 除IE7、IE9比较的是父级border的内边缘与当前元素的外边缘， firefox、chrome、ie8是父级border的外边缘与当前元素的外边缘 </p>
<p><code>clientTop、clientLeft</code>: 一般返回元素的border宽度</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS常用原生函数汇总</title>
    <url>/2017/11/09/JS%E5%B8%B8%E7%94%A8%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>工作中经常用到的方法。</p>
<a id="more"></a>
<h2 id="type-类型判断"><a href="#type-类型判断" class="headerlink" title="type 类型判断"></a>type 类型判断</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">isString (o) &#123; <span class="comment">//是否字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'String'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isNumber (o) &#123; <span class="comment">//是否数字</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Number'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isObj (o) &#123; <span class="comment">//是否对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Object'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isArray (o) &#123; <span class="comment">//是否数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Array'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isDate (o) &#123; <span class="comment">//是否时间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Date'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isBoolean (o) &#123; <span class="comment">//是否boolean</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Boolean'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isFunction (o) &#123; <span class="comment">//是否函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Function'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isNull (o) &#123; <span class="comment">//是否为null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Null'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isUndefined (o) &#123; <span class="comment">//是否undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(o).slice(<span class="number">8</span>, <span class="number">-1</span>) === <span class="string">'Undefined'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isFalse (o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!o || o === <span class="string">'null'</span> || o === <span class="string">'undefined'</span> || o === <span class="string">'false'</span> || o === <span class="string">'NaN'</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isTrue (o) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="keyword">this</span>.isFalse(o)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isIos () &#123;</span><br><span class="line">    <span class="keyword">var</span> u = navigator.userAgent;</span><br><span class="line">    <span class="keyword">if</span> (u.indexOf(<span class="string">'Android'</span>) &gt; <span class="number">-1</span> || u.indexOf(<span class="string">'Linux'</span>) &gt; <span class="number">-1</span>) &#123;<span class="comment">//安卓手机</span></span><br><span class="line">        <span class="comment">// return "Android";</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u.indexOf(<span class="string">'iPhone'</span>) &gt; <span class="number">-1</span>) &#123;<span class="comment">//苹果手机</span></span><br><span class="line">        <span class="comment">// return "iPhone";</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u.indexOf(<span class="string">'iPad'</span>) &gt; <span class="number">-1</span>) &#123;<span class="comment">//iPad</span></span><br><span class="line">        <span class="comment">// return "iPad";</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u.indexOf(<span class="string">'Windows Phone'</span>) &gt; <span class="number">-1</span>) &#123;<span class="comment">//winphone手机</span></span><br><span class="line">        <span class="comment">// return "Windows Phone";</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isPC () &#123; <span class="comment">//是否为PC端</span></span><br><span class="line">    <span class="keyword">var</span> userAgentInfo = navigator.userAgent;</span><br><span class="line">    <span class="keyword">var</span> Agents = [<span class="string">"Android"</span>, <span class="string">"iPhone"</span>,</span><br><span class="line">                <span class="string">"SymbianOS"</span>, <span class="string">"Windows Phone"</span>,</span><br><span class="line">                <span class="string">"iPad"</span>, <span class="string">"iPod"</span>];</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> v = <span class="number">0</span>; v &lt; Agents.length; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (userAgentInfo.indexOf(Agents[v]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">browserType()&#123;</span><br><span class="line">    <span class="keyword">var</span> userAgent = navigator.userAgent; <span class="comment">//取得浏览器的userAgent字符串</span></span><br><span class="line">    <span class="keyword">var</span> isOpera = userAgent.indexOf(<span class="string">"Opera"</span>) &gt; <span class="number">-1</span>; <span class="comment">//判断是否Opera浏览器</span></span><br><span class="line">    <span class="keyword">var</span> isIE = userAgent.indexOf(<span class="string">"compatible"</span>) &gt; <span class="number">-1</span> &amp;&amp; userAgent.indexOf(<span class="string">"MSIE"</span>) &gt; <span class="number">-1</span> &amp;&amp; !isOpera; <span class="comment">//判断是否IE浏览器</span></span><br><span class="line">    <span class="keyword">var</span> isEdge = userAgent.indexOf(<span class="string">"Edge"</span>) &gt; <span class="number">-1</span>; <span class="comment">//判断是否IE的Edge浏览器</span></span><br><span class="line">    <span class="keyword">var</span> isFF = userAgent.indexOf(<span class="string">"Firefox"</span>) &gt; <span class="number">-1</span>; <span class="comment">//判断是否Firefox浏览器</span></span><br><span class="line">    <span class="keyword">var</span> isSafari = userAgent.indexOf(<span class="string">"Safari"</span>) &gt; <span class="number">-1</span> &amp;&amp; userAgent.indexOf(<span class="string">"Chrome"</span>) == <span class="number">-1</span>; <span class="comment">//判断是否Safari浏览器</span></span><br><span class="line">    <span class="keyword">var</span> isChrome = userAgent.indexOf(<span class="string">"Chrome"</span>) &gt; <span class="number">-1</span> &amp;&amp; userAgent.indexOf(<span class="string">"Safari"</span>) &gt; <span class="number">-1</span>; <span class="comment">//判断Chrome浏览器</span></span><br><span class="line">    <span class="keyword">if</span> (isIE) &#123;</span><br><span class="line">        <span class="keyword">var</span> reIE = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"MSIE (\\d+\\.\\d+);"</span>);</span><br><span class="line">        reIE.test(userAgent);</span><br><span class="line">        <span class="keyword">var</span> fIEVersion = <span class="built_in">parseFloat</span>(<span class="built_in">RegExp</span>[<span class="string">"$1"</span>]);</span><br><span class="line">        <span class="keyword">if</span>(fIEVersion == <span class="number">7</span>) <span class="keyword">return</span> <span class="string">"IE7"</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fIEVersion == <span class="number">8</span>) <span class="keyword">return</span> <span class="string">"IE8"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fIEVersion == <span class="number">9</span>) <span class="keyword">return</span> <span class="string">"IE9"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fIEVersion == <span class="number">10</span>) <span class="keyword">return</span> <span class="string">"IE10"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fIEVersion == <span class="number">11</span>) <span class="keyword">return</span> <span class="string">"IE11"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"IE7以下"</span><span class="comment">//IE版本过低</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isFF) <span class="keyword">return</span> <span class="string">"FF"</span>;</span><br><span class="line">    <span class="keyword">if</span> (isOpera) <span class="keyword">return</span> <span class="string">"Opera"</span>;</span><br><span class="line">    <span class="keyword">if</span> (isEdge) <span class="keyword">return</span> <span class="string">"Edge"</span>;</span><br><span class="line">    <span class="keyword">if</span> (isSafari) <span class="keyword">return</span> <span class="string">"Safari"</span>;</span><br><span class="line">    <span class="keyword">if</span> (isChrome) <span class="keyword">return</span> <span class="string">"Chrome"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkStr (str, type) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'phone'</span>:   <span class="comment">//手机号码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^1[3|4|5|7|8][0-9]&#123;9&#125;$/</span>.test(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'tel'</span>:     <span class="comment">//座机</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/</span>.test(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'card'</span>:    <span class="comment">//身份证</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/</span>.test(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'pwd'</span>:     <span class="comment">//密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^[a-zA-Z]\w&#123;5,17&#125;$/</span>.test(str)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'postal'</span>:  <span class="comment">//邮政编码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/[1-9]\d&#123;5&#125;(?!\d)/</span>.test(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'QQ'</span>:      <span class="comment">//QQ号</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^[1-9][0-9]&#123;4,9&#125;$/</span>.test(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'email'</span>:   <span class="comment">//邮箱</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/</span>.test(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'money'</span>:   <span class="comment">//金额(小数点2位)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^\d*(?:\.\d&#123;0,2&#125;)?$/</span>.test(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'URL'</span>:     <span class="comment">//网址</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&amp;:/~\+#]*[\w\-\@?^=%&amp;/~\+#])?/</span>.test(str)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'IP'</span>:      <span class="comment">//IP</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))/</span>.test(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'date'</span>:    <span class="comment">//日期时间</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;) (\d&#123;2&#125;)(?:\:\d&#123;2&#125;|:(\d&#123;2&#125;):(\d&#123;2&#125;))$/</span>.test(str) || <span class="regexp">/^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;)$/</span>.test(str)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'number'</span>:  <span class="comment">//数字</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^[0-9]$/</span>.test(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'english'</span>: <span class="comment">//英文</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^[a-zA-Z]+$/</span>.test(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'chinese'</span>: <span class="comment">//中文</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^[\u4E00-\u9FA5]+$/</span>.test(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'lower'</span>:   <span class="comment">//小写</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^[a-z]+$/</span>.test(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'upper'</span>:   <span class="comment">//大写</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/^[A-Z]+$/</span>.test(str);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'HTML'</span>:    <span class="comment">//HTML标记</span></span><br><span class="line">            <span class="keyword">return</span> <span class="regexp">/&lt;("[^"]*"|'[^']*'|[^'"&gt;])*&gt;/</span>.test(str);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 格式化时间</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param  &#123;time&#125; 时间</span></span><br><span class="line"><span class="comment"> * @param  &#123;cFormat&#125; 格式</span></span><br><span class="line"><span class="comment"> * @return &#123;String&#125; 字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @example formatTime('2018-1-29', '&#123;y&#125;/&#123;m&#125;/&#123;d&#125; &#123;h&#125;:&#123;i&#125;:&#123;s&#125;') // -&gt; 2018/01/29 00:00:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatTime</span>(<span class="params">time, cFormat</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> ((time + <span class="string">''</span>).length === <span class="number">10</span>) &#123;</span><br><span class="line">        time = +time * <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> format = cFormat || <span class="string">'&#123;y&#125;-&#123;m&#125;-&#123;d&#125; &#123;h&#125;:&#123;i&#125;:&#123;s&#125;'</span>, date</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> time === <span class="string">'object'</span>) &#123;</span><br><span class="line">        date = time</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        date = <span class="keyword">new</span> <span class="built_in">Date</span>(time)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> formatObj = &#123;</span><br><span class="line">        y: date.getFullYear(),</span><br><span class="line">        m: date.getMonth() + <span class="number">1</span>,</span><br><span class="line">        d: date.getDate(),</span><br><span class="line">        h: date.getHours(),</span><br><span class="line">        i: date.getMinutes(),</span><br><span class="line">        s: date.getSeconds(),</span><br><span class="line">        a: date.getDay()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> time_str = format.replace(<span class="regexp">/&#123;(y|m|d|h|i|s|a)+&#125;/g</span>, (result, key) =&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> value = formatObj[key]</span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">'a'</span>) <span class="keyword">return</span> [<span class="string">'一'</span>, <span class="string">'二'</span>, <span class="string">'三'</span>, <span class="string">'四'</span>, <span class="string">'五'</span>, <span class="string">'六'</span>, <span class="string">'日'</span>][value - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> (result.length &gt; <span class="number">0</span> &amp;&amp; value &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            value = <span class="string">'0'</span> + value</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value || <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> time_str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*判断一个元素是否在数组中*/</span></span><br><span class="line">contains (arr, val) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.indexOf(val) != <span class="number">-1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取url参数"><a href="#获取url参数" class="headerlink" title="获取url参数"></a>获取url参数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryString</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^|&amp;)"</span> + name + <span class="string">"=([^&amp;]*)(&amp;|$)"</span>);</span><br><span class="line">  <span class="keyword">var</span> r = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).match(reg);</span><br><span class="line">  <span class="keyword">if</span> (r != <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">unescape</span>(r[<span class="number">2</span>]); <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单去抖函数"><a href="#简单去抖函数" class="headerlink" title="简单去抖函数"></a>简单去抖函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">time, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>,</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      fn.apply(ctx, args)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>原生函数</tag>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用操作命令</title>
    <url>/2017/10/31/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="git-分支操作"><a href="#git-分支操作" class="headerlink" title="git 分支操作"></a>git 分支操作</h2><h3 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h3><p><code>git branch</code></p>
<h3 id="查看远程分支"><a href="#查看远程分支" class="headerlink" title="查看远程分支"></a>查看远程分支</h3><p><code>git branch -a</code></p>
<h3 id="创建本地分支"><a href="#创建本地分支" class="headerlink" title="创建本地分支"></a>创建本地分支</h3><p><code>git branch (br)</code></p>
<a id="more"></a>
<h3 id="把分支推到远程分支"><a href="#把分支推到远程分支" class="headerlink" title="把分支推到远程分支"></a>把分支推到远程分支</h3><p><code>git push origin (br)</code></p>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p><code>git checkout (br)</code></p>
<h3 id="git-删除本地分支"><a href="#git-删除本地分支" class="headerlink" title="git 删除本地分支"></a>git 删除本地分支</h3><p><code>git branch -D (br)</code></p>
<h3 id="git-删除远程分支"><a href="#git-删除远程分支" class="headerlink" title="git 删除远程分支"></a>git 删除远程分支</h3><p><code>git push origin :br  (origin 后面有空格)</code></p>
<h3 id="git代码库回滚-指的是将代码库某分支退回到以前的某个commit-id"><a href="#git代码库回滚-指的是将代码库某分支退回到以前的某个commit-id" class="headerlink" title="git代码库回滚: 指的是将代码库某分支退回到以前的某个commit id"></a>git代码库回滚: 指的是将代码库某分支退回到以前的某个commit id</h3><h4 id="本地代码库回滚"><a href="#本地代码库回滚" class="headerlink" title="本地代码库回滚"></a>本地代码库回滚</h4><p><code>git reset --hard commit-id :回滚到commit-id，讲commit-id之后提交的commit都去除</code><br><code>git reset --hard HEAD~3：将最近3次的提交回滚</code></p>
<h4 id="远程代码库回滚"><a href="#远程代码库回滚" class="headerlink" title="远程代码库回滚"></a>远程代码库回滚</h4><p>应用场景：自动部署系统发布后发现问题，需要回滚到某一个commit，再重新发布</p>
<p>原理：先将本地分支退回到某个commit，删除远程分支，再重新push本地分支</p>
<p>操作步骤：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、git checkout the_branch</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、git pull</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、git branch the_branch_backup <span class="comment">//备份一下这个分支当前的情况</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、git reset --hard the_commit_id <span class="comment">//把the_branch本地回滚到the_commit_id</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>、git push origin :the_branch <span class="comment">//删除远程 the_branch</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span>、git push origin the_branch <span class="comment">//用回滚后的本地分支重新建立远程分支</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>、git push origin :the_branch_backup <span class="comment">//如果前面都成功了，删除这个备份分支</span></span><br></pre></td></tr></table></figure>
<p>如果使用了gerrit做远程代码中心库和code review平台，需要确保操作git的用户具备分支的push权限，并且选择了 Force Push选项（在push权限设置里有这个选项）</p>
<p>另外，gerrit中心库是个bare库，将HEAD默认指向了master，因此master分支是不能进行删除操作的，最好不要选择删除master分支的策略，换用其他分支。如果一定要这样做，可以考虑到gerrit服务器上修改HEAD指针。。。不建议这样搞</p>
<p>转载自：<a href="http://www.cnblogs.com/hqbhonker/p/5092300.html" target="_blank" rel="noopener">http://www.cnblogs.com/hqbhonker/p/5092300.html</a></p>
<h2 id="git删除远程仓库文件或目录"><a href="#git删除远程仓库文件或目录" class="headerlink" title="git删除远程仓库文件或目录"></a>git删除远程仓库文件或目录</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git rm --cached ./file.txt //删除目录下的file.txt文件</span><br><span class="line"></span><br><span class="line">git rm -r --cached folder  //删除目录folder</span><br><span class="line"></span><br><span class="line">git commit -m &quot;删除操作&quot;</span><br><span class="line"></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Git</tag>
        <tag>Git命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Flex布局</title>
    <url>/2017/10/23/Flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="Flex-布局是什么？"><a href="#Flex-布局是什么？" class="headerlink" title="Flex 布局是什么？"></a>Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>任何一个容器都可以指定为 Flex 布局。</p>
<a id="more"></a>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>行内元素也可以使用 Flex 布局。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p>
</blockquote>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p>
<p><img src="http://oy9tlpm12.bkt.clouddn.com/bg2015071004.png" alt></p>
]]></content>
  </entry>
  <entry>
    <title>Hexo博客从一台电脑迁移到其他电脑</title>
    <url>/2017/10/23/Hexo%E5%8D%9A%E5%AE%A2%E4%BB%8E%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E8%BF%81%E7%A7%BB%E5%88%B0%E5%85%B6%E4%BB%96%E7%94%B5%E8%84%91/</url>
    <content><![CDATA[<p>hexo官方给了一些迁移的方法，不过它上面介绍的方法都是把博客文章从hexo系统迁移到其他博客系统的方法。然而我们这里要讨论的是：</p>
<p>当我们更换电脑的时候我们应该怎么办？</p>
<p>所以默认你已经成功利用hexo和github发布博客，如果还没有，可以看一下<a href="http://lixiaolai.com/2016/06/22/makecs-build-a-blog-with-hexo-on-github/" target="_blank" rel="noopener">教程</a></p>
<p>具体的思路是：在生成的已经推到github上的hexo静态代码出建立一个分支，利用这个分支来管理自己hexo的源文件。</p>
<a id="more"></a>
<p>如果能在刚刚配置hexo的时候就想好以后的迁移的问题就太好了，可以省掉很多麻烦，可实际使用中，刚刚配置hexo的时候，好多人都是初学，不会想到以后的问题，我就是这样的。</p>
<p>具体的操作：</p>
<p>克隆gitHub上面生成的静态文件到本地</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/yourname/hexo-test.github.io.git</span></span><br></pre></td></tr></table></figure>
<p>把克隆到本地的文件除了git的文件都删掉，找不到git的文件的话就到删了吧。不要用<code>hexo init</code>初始化。</p>
<p>将之前使用hexo写博客时候的整个目录（所有文件）搬过来。把该忽略的文件忽略了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch .gitignore</span><br></pre></td></tr></table></figure></p>
<p>创建一个叫hexo的分支<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b hexo</span><br></pre></td></tr></table></figure></p>
<p>提交复制过来的文件到暂存区<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add --all</span><br></pre></td></tr></table></figure></p>
<p>提交<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;新建分支源文件&quot;</span><br></pre></td></tr></table></figure></p>
<p>推送分支到github<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin hexo</span><br></pre></td></tr></table></figure></p>
<p>到这里基本上就搞定了，以后再推就可以直接git push了，hexo的操作跟以前一样。</p>
<p>今后无论什么时候想要在其他电脑上面用hexo写博客，就直接把创建的分支克隆下来，<code>npm install</code>安装依赖之后就可以用了。</p>
<p>克隆分支的操作<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b hexo https://github.com/yourname/hexo-test.github.io.git</span><br></pre></td></tr></table></figure></p>
<p>因为上面创建的是一个名字叫hexo的分支，所以这里-b后面的是hexo，再把后面的gitHub的地址换成你自己的hexo博客的地址就可以了。</p>
<p>这样做完了以后，每次写完博客发布之后不要忘了还要git push把源文件推到分支上。</p>
]]></content>
      <tags>
        <tag>hexo本地更新</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令集合</title>
    <url>/2017/10/23/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h1><h2 id="添加nginx网站"><a href="#添加nginx网站" class="headerlink" title="添加nginx网站"></a>添加nginx网站</h2><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>关闭虚拟机防火墙：</p>
<p>关闭命令： <code>service iptables stop</code></p>
<p>永久关闭防火墙：<code>chkconfig iptables off</code></p>
<p>两个命令同时运行，运行完成后查看防火墙关闭状态<br><code>service iptables status</code></p>
<ul>
<li>关闭防火墙—–<code>service iptables stop</code></li>
<li>启动防火墙—–<code>service iptables start</code></li>
<li>重启防火墙—–<code>service iptables restart</code> </li>
<li>查看防火墙状态–<code>service iptables status</code></li>
<li>永久关闭防火墙–<code>chkconfig iptables off</code> </li>
<li>永久关闭后启用–<code>chkconfig iptables on</code></li>
</ul>
]]></content>
      <tags>
        <tag>服务器配置</tag>
        <tag>linux</tag>
        <tag>后台</tag>
      </tags>
  </entry>
  <entry>
    <title>了解一下JS的正则表达式</title>
    <url>/2017/09/22/%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BJS%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义-Define"><a href="#定义-Define" class="headerlink" title="定义 Define"></a>定义 Define</h2><p>正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式或者说对象被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法。</p>
<p>RegExp 是一个用于创建正则表达式对象的构造函数，用于将文本与一个模式匹配。</p>
<h2 id="创建一个正则表达式"><a href="#创建一个正则表达式" class="headerlink" title="创建一个正则表达式"></a>创建一个正则表达式</h2><p>有两种方法创建一个正则表达式。</p>
<a id="more"></a>
<h3 id="1-字面量方式"><a href="#1-字面量方式" class="headerlink" title="1. 字面量方式"></a>1. 字面量方式</h3><p>由包含在斜杠之间的模式组成，如下所示:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   /pattern/flags </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/pattern/</span>;</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/ab+c/</span>;</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[a-zA-Z]+[0-9]*\W?_$/gi</span>;</span><br></pre></td></tr></table></figure>
<p>在加载脚本后，正则表达式字面值提供正则表达式的编译。当正则表达式保持不变时，使用此方法可获得更好的性能。</p>
<h3 id="2-RegExp实例创建"><a href="#2-RegExp实例创建" class="headerlink" title="2. RegExp实例创建"></a>2. RegExp实例创建</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    new RegExp(pattern [, flags])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"ab+c"</span>);</span><br><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/ab+c/</span>); <span class="comment">// 与上面等价</span></span><br><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/^[a-zA-Z]+[0-9]*\W?_$/</span>, <span class="string">"gi"</span>);</span><br><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"^[a-zA-Z]+[0-9]*\W?_$"</span>, <span class="string">"gi"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>字面量方式和实例创建的方式在正则中的区别?<br>1、字面量形式提供正则表达式的编译（compilation）状态，当正则表达式保持为常量时使用字面量。而构造函数方式，如<code>new RegExp(&#39;ab+c&#39;)</code>提供了正则表达式运行时编译（runtime compilation）。<br>2、字面量方式中出现的一切都是元字符,所以不能进行变量值的拼接，而实例创建的方式是可以的。实例创建方式的好处在于可以在运行时编译，这个特性可以方便用来处理用户输入。<br>3、字面量中直接写\d就可以，而在实例中有两种情况，如果直接使用/pattern/这种方式创建与字面量方式书写无区别，即\d，如果是带双引号，双引号内的需要把它转译\\d</li>
</ul>
</blockquote>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Jack'</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^\d+name+\d+$/</span>; <span class="comment">//这样写是无效的 必须得用实例创建</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> RexExp(<span class="string">"^\\d"</span> + name + <span class="string">"\\d+$"</span>,<span class="string">"g"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="RegExp对象的参数"><a href="#RegExp对象的参数" class="headerlink" title="RegExp对象的参数"></a>RegExp对象的参数</h4><p><code>pattern</code>:正则表达式的文本。</p>
<p><code>flags</code>:可以具有以下值的任意组合：</p>
<blockquote>
<p><code>g</code>：全局匹配;找到所有匹配，而不是在第一个匹配后停止<br><code>i</code>：忽略大小写<br><code>m</code>：多行; 将开始和结束字符（^和$）视为在多行上工作（例如，分别匹配每一行的开始和结束（由 \n 或 \r 分割），而不只是只匹配整个输入字符串的最开始和最末尾处。<br><code>u</code>：Unicode; 将模式视为Unicode序列点的序列<br><code>y</code>：粘性匹配; 仅匹配目标字符串中此正则表达式的lastIndex属性指示的索引(并且不尝试从任何后续的索引匹配)。</p>
</blockquote>
<p><strong>从ECMAScript 6开始</strong>，当第一个参数为正则表达式而第二个标志参数存在时，<code>new RegExp(/ab+c/, &#39;i&#39;)</code>不再抛出TypeError （“当从其他正则表达式进行构造时不支持标志”）的异常，取而代之，将使用这些参数创建一个新的正则表达式。</p>
<h2 id="写一个正则表达式"><a href="#写一个正则表达式" class="headerlink" title="写一个正则表达式"></a>写一个正则表达式</h2><p>一个正则表达式模式是由简单的字符所构成的，比如<code>/abc/</code>, 或者是简单和特殊字符的组合，比如 <code>/ab*c/</code> 或 <code>/Chapter (\d+)\.\d*/</code>。后者用到了括号，它在正则表达式中可以被用作是一个记忆设备。这一部分正则所匹配的字符将会被记住，在后面可以被利用。正如 <a href="#使用括号的子字符串匹配">使用括号的子字符串匹配</a>。</p>
<h3 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h3><p>简单模式是由你找到的直接匹配所构成的。比如，/abc/这个模式就匹配了在一个字符串中，仅仅字符 <code>&#39;abc&#39;</code> 同时出现并按照这个顺序。在 <code>&quot;Hi, do you know your abc&#39;s?&quot;</code> 和 <code>&quot;The latest airplane designs evolved from slabcraft.&quot;</code> 就会匹配成功。在上面的两个实例中，匹配的是子字符串 <code>&#39;abc&#39;</code>。在字符串 <code>&quot;Grab crab&quot;</code> 中将不会被匹配，因为它不包含任何的 ‘abc’ 子字符串。</p>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>当你需要搜索一个比直接匹配需要更多条件的匹配时，比如寻找一个或多个 ‘b’，或者寻找空格，那么这时模式将要包含特殊字符。比如， 模式<code>/ab*c/</code>匹配了一个单独的 ‘a’ 后面跟了零个或者多个 ‘b’（*的意思是前面一项出现了零个或者多个），且后面跟着 ‘c’ 的任何字符组合。在字符串 <code>&quot;cbbabbbbcdebc&quot;</code> 中，这个模式匹配了子字符串 <code>&quot;abbbbc&quot;</code>。</p>
<h4 id="正则表达式中的特殊字符"><a href="#正则表达式中的特殊字符" class="headerlink" title="正则表达式中的特殊字符"></a>正则表达式中的特殊字符</h4><ul>
<li><a href="#字符类别">字符类别（Character Classes）</a></li>
<li><a href="#字符集合">字符集合（Character Sets）</a></li>
<li><a href="边界">边界（Boundaries）</a></li>
<li><a href="#分组与反向引用">分组（grouping）与反向引用（back references）</a></li>
<li><a href="#数量词">数量词（Quantifiers）</a></li>
<li><a href="#断言">断言（Assertions）</a></li>
</ul>
<h4 id="字符类别"><a href="#字符类别" class="headerlink" title="字符类别"></a>字符类别</h4><h5 id="点号，小数点"><a href="#点号，小数点" class="headerlink" title=".(点号，小数点)"></a><code>.(点号，小数点)</code></h5><p>匹配任意单个字符，但是行结束符除外：<code>\n \r \u2028</code> 或 <code>\u2029</code>。</p>
<p>在字符集中，点( . )失去其特殊含义，并匹配一个字面点( . )。</p>
<p>需要注意的是，m 多行（multiline）标志不会改变点号的表现。因此为了匹配多行中的字符集，可使用[^] （当然你不是打算用在旧版本 IE 中），它将会匹配任意字符，包括换行符。</p>
<p>例如，<code>/.y/</code> 匹配 <code>&quot;yes make my day&quot;</code> 中的 <code>&quot;my&quot;</code> 和 <code>&quot;ay&quot;</code>，但是不匹配 <code>&quot;yes&quot;</code>。</p>
<h5 id="d"><a href="#d" class="headerlink" title="\d"></a><code>\d</code></h5><p>匹配任意阿拉伯数字。等价于[0-9]。</p>
<p>例如，<code>/\d/</code> 或 <code>/[0-9]/</code> 匹配 “B2 is the suite number.” 中的 ‘2’。 </p>
<blockquote>
<ul>
<li><code>\d</code> 表示数字，即 digit，<code>\w</code> 表示单词，等同于 <code>[A-Za-z0-9_]</code>，原文就是 word。</li>
</ul>
</blockquote>
<h5 id="D"><a href="#D" class="headerlink" title="\D"></a><code>\D</code></h5><p>匹配任意一个不是阿拉伯数字的字符。等价于[^0-9]。</p>
<p>例如，<code>/\D/</code> 或 <code>/[^0-9]/</code> 匹配 “B2 is the suite number.” 中的 ‘B’。</p>
<h5 id="w"><a href="#w" class="headerlink" title="\w"></a><code>\w</code></h5><p>匹配任意来自基本拉丁字母表中的字母数字字符，还包括下划线。等价于 <code>[A-Za-z0-9_]</code>。</p>
<p>例如，<code>/\w/</code> 匹配 “apple” 中的 ‘a’，”$5.28” 中的 ‘5’ 和 “3D” 中的 ‘3’。</p>
<h5 id="W"><a href="#W" class="headerlink" title="\W"></a><code>\W</code></h5><p>匹配任意不是基本拉丁字母表中单词（字母数字下划线）字符的字符。等价于 <code>[^A-Za-z0-9_]</code>。</p>
<p>例如，<code>/\W/</code> 或 /[^A-Za-z0-9_]/ 匹配 “50%” 中的 ‘%’。</p>
<h5 id="s"><a href="#s" class="headerlink" title="\s"></a><code>\s</code></h5><p>匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。</p>
<p>等价于 <code>[ \f\n\r\t\v​\u00a0\u1680​\u180e\u2000​\u2001\u2002​\u2003\u2004​ \u2005\u2006​\u2007\u2008​\u2009\u200a​\u2028\u2029​​\u202f\u205f​ \u3000]</code>。</p>
<p>例如 <code>/\s\w*/</code> 匹配 “foo bar” 中的 ‘ bar’。</p>
<h5 id="S"><a href="#S" class="headerlink" title="\S"></a><code>\S</code></h5><p>匹配一个非空白符。等价于 <code>[^ \f\n\r\t\v​\u00a0\u1680​\u180e\u2000​\u2001\u2002​\u2003\u2004​ \u2005\u2006​\u2007\u2008​\u2009\u200a​\u2028\u2029​\u202f\u205f​\u3000]</code>。</p>
<p>例如，<code>/\S\w*/</code> 匹配 “foo bar” 中的 ‘foo’。</p>
<h5 id="t"><a href="#t" class="headerlink" title="\t"></a><code>\t</code></h5><p>匹配一个水平制表符（tab）</p>
<h5 id="r"><a href="#r" class="headerlink" title="\r"></a><code>\r</code></h5><p>匹配一个回车符（carriage return）</p>
<blockquote>
<ul>
<li>回车 <code>\r</code> 本义是光标重新回到本行开头，r 即 return。</li>
</ul>
</blockquote>
<h5 id="n"><a href="#n" class="headerlink" title="\n"></a><code>\n</code></h5><p>匹配一个换行符（linefeed）</p>
<h5 id="v"><a href="#v" class="headerlink" title="\v"></a><code>\v</code></h5><p>匹配一个垂直制表符（vertical tab）</p>
<h5 id="f"><a href="#f" class="headerlink" title="\f"></a><code>\f</code></h5><p>匹配一个换页符（form-feed）</p>
<h5 id="b"><a href="#b" class="headerlink" title="[\b]"></a><code>[\b]</code></h5><p>匹配一个退格符（backspace）（不要与 \b 混淆）</p>
<h5 id="0"><a href="#0" class="headerlink" title="\0"></a><code>\0</code></h5><p>匹配一个 NUL 字符。不要在此后面跟小数点。</p>
<h5 id="cX"><a href="#cX" class="headerlink" title="\cX"></a><code>\cX</code></h5><p>X 是 A - Z 的一个字母。匹配字符串中的一个控制字符。</p>
<p>例如，<code>/\cM/</code> 匹配字符串中的 control-M。</p>
<h5 id="xhh"><a href="#xhh" class="headerlink" title="\xhh"></a><code>\xhh</code></h5><p>匹配编码为 <code>hh</code> （两个十六进制数字）的字符。</p>
<h5 id="uhhhh"><a href="#uhhhh" class="headerlink" title="\uhhhh"></a><code>\uhhhh</code></h5><p>匹配 Unicode 值为 hhhh （四个十六进制数字）的字符。</p>
<h5 id="反斜杠"><a href="#反斜杠" class="headerlink" title="\(反斜杠)"></a><code>\(反斜杠)</code></h5><p>对于那些通常被认为字面意义的字符来说，表示下一个字符具有特殊用处，并且不会被按照字面意义解释。</p>
<p>例如 <code>/b/</code> 匹配字符 ‘b’。在 b 前面加上一个反斜杠，即使用 <code>/\b/</code>，则该字符变得特殊，以为这匹配一个单词边界。</p>
<p>或</p>
<p>对于那些通常特殊对待的字符，表示下一个字符不具有特殊用途，会被按照字面意义解释。</p>
<p>例如，<code>*</code> 是一个特殊字符，表示匹配某个字符 0 或多次，如 <code>/a*/</code> 意味着 0 或多个 “a”。 为了匹配字面意义上的 <code>*</code> ，在它前面加上一个反斜杠，例如，<code>/a\*/</code>匹配 ‘a*’。</p>
<h4 id="字符集合"><a href="#字符集合" class="headerlink" title="字符集合"></a>字符集合</h4><h5 id="xyz"><a href="#xyz" class="headerlink" title="[xyz]"></a><code>[xyz]</code></h5><p>一个字符集合，也叫字符组。匹配集合中的任意一个字符。你可以使用连字符’<code>-</code>‘指定一个范围。</p>
<p>例如，<code>[abcd]</code> 等价于 <code>[a-d]</code>，匹配”<code>brisket</code>“中的’b’和”<code>chop</code>“中的’c’。</p>
<h5 id="xyz-1"><a href="#xyz-1" class="headerlink" title="[^xyz]"></a><code>[^xyz]</code></h5><p>一个反义或补充字符集，也叫反义字符组。也就是说，它匹配任意不在括号内的字符。你也可以通过使用连字符 ‘-‘ 指定一个范围内的字符。</p>
<p>例如，<code>[^abc]</code> 等价于 <code>[^a-c]</code>。 第一个匹配的是 “bacon” 中的’o’ 和 “chop” 中的 ‘h’。</p>
<h4 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h4><h5 id><a href="#" class="headerlink" title="^"></a><code>^</code></h5><p>匹配输入开始。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符后的开始处。</p>
<p>例如，<code>/^A/</code> 不匹配 “an A” 中的 “A”，但匹配 “An A” 中的 “A”。</p>
<blockquote>
<ul>
<li>换行 <code>\n</code> 本义是光标往下一行（不一定到下一行行首），n 即 newline。</li>
</ul>
</blockquote>
<h5 id="-1"><a href="#-1" class="headerlink" title="$"></a><code>$</code></h5><p>匹配输入结尾。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符的前的结尾处。</p>
<p>例如，<code>/t$/</code> 不匹配 “eater” 中的 “t”，但匹配 “eat” 中的 “t”。</p>
<h5 id="b-1"><a href="#b-1" class="headerlink" title="\b"></a><code>\b</code></h5><p>匹配一个零宽单词边界（zero-width word boundary），如一个字母与一个空格之间。 （不要和 <code>[\b]</code> 混淆）</p>
<p>例如，<code>/\bno/</code> 匹配 “at noon” 中的 “no”，<code>/ly\b/</code> 匹配 “possibly yesterday.” 中的 “ly”。</p>
<h5 id="B"><a href="#B" class="headerlink" title="\B"></a><code>\B</code></h5><p>匹配一个零宽非单词边界（zero-width non-word boundary），如两个字母之间或两个空格之间。</p>
<p>例如，<code>/\Bon/</code> 匹配 “at noon” 中的 “on”，<code>/ye\B/</code> 匹配 “possibly yesterday.” 中的 “ye”。</p>
<h4 id="分组与反向引用"><a href="#分组与反向引用" class="headerlink" title="分组与反向引用"></a>分组与反向引用</h4><h5 id="x"><a href="#x" class="headerlink" title="(x)"></a><code>(x)</code></h5><p>匹配 <code>x</code> 并且捕获匹配项。 这被称为捕获括号（capturing parentheses）。</p>
<p>例如，<code>/(foo)/</code> 匹配且捕获 “foo bar.” 中的 “foo”。被匹配的子字符串可以在结果数组的元素 <code>[1], ..., [n]</code> 中找到，或在被定义的 RegExp 对象的属性 $1, …, $9 中找到。</p>
<p>捕获组（Capturing groups）有性能惩罚。如果不需再次访问被匹配的子字符串，最好使用非捕获括号（non-capturing parentheses），见下面。</p>
<h5 id="x-1"><a href="#x-1" class="headerlink" title="(?:x)"></a><code>(?:x)</code></h5><p>匹配 <code>x</code> 不会捕获匹配项。这被称为非捕获括号（non-capturing parentheses）。匹配项不能够从结果数组的元素 <code>[1], ..., [n]</code> 或已被定义的 <code>RegExp</code> 对象的属性 <code>$1, ..., $9</code> 再次访问到。</p>
<h5 id="n-1"><a href="#n-1" class="headerlink" title="\n"></a><code>\n</code></h5><p><code>n</code> 是一个正整数。一个反向引用（back reference），指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串。</p>
<p>例如，<code>/apple(,)\sorange\1/</code> 匹配 “apple, orange, cherry, peach.” 中的 “apple,orange,”。一个更全面的例子在下面。</p>
<h4 id="数量词"><a href="#数量词" class="headerlink" title="数量词"></a>数量词</h4><h5 id="x-2"><a href="#x-2" class="headerlink" title="x*"></a><code>x*</code></h5><p>匹配前面的模式 x 0 或多次。</p>
<p>例如，<code>/bo*/</code> 匹配 “A ghost booooed” 中的 “boooo”，”A bird warbled” 中的 “b”，但是不匹配 “A goat grunted”。</p>
<h5 id="x-3"><a href="#x-3" class="headerlink" title="x+"></a><code>x+</code></h5><p>匹配前面的模式 x 1 或多次。等价于 <code>{1,}</code>。</p>
<p>例如，<code>/a+/</code> 匹配 “candy” 中的 “a”，”caaaaaaandy” 中所有的 “a”。</p>
<h5 id="x-x"><a href="#x-x" class="headerlink" title="x*? x+?"></a><code>x*?</code> <code>x+?</code></h5><p>像上面的 * 和 + 一样匹配前面的模式 x，然而匹配是最小可能匹配。</p>
<p>例如，<code>/&quot;.*?&quot;/</code> 匹配 ‘“foo” “bar”‘ 中的 ‘“foo”‘，而 * 后面没有 ? 时匹配 ‘“foo” “bar”‘。</p>
<h5 id="x-4"><a href="#x-4" class="headerlink" title="x?"></a><code>x?</code></h5><p>匹配前面的模式 x 0 或 1 次。</p>
<p>例如，<code>/e?le?/</code> 匹配 “angel” 中的 “el”，”angle” 中的 “le”。</p>
<p>如果在数量词 <code>*</code>、<code>+</code>、<code>?</code> 或 <code>{}</code>, 任意一个后面紧跟该符号（?），会使数量词变为非贪婪（ non-greedy） ，即匹配次数最小化。反之，默认情况下，是贪婪的（greedy），即匹配次数最大化。</p>
<p>在使用于向前断言（lookahead assertions）时，见该表格中 <code>(?=)、`</code>(?!)<code>和</code>(?:)` 的说明。</p>
<h5 id="x-y"><a href="#x-y" class="headerlink" title="x(?=y)"></a><code>x(?=y)</code></h5><p>只有当 <code>x</code> 后面不是紧跟着 <code>y</code> 时，才匹配 <code>x</code>。例如，<code>/\d+(?!\.)/</code> 只有当一个数字后面没有紧跟着一个小数点时，才会匹配该数字。</p>
<p><code>/\d+(?!\.)/.exec(&quot;3.141&quot;)</code> 匹配 141 而不是 3.141。</p>
<h5 id="x-y-1"><a href="#x-y-1" class="headerlink" title="x|y"></a><code>x|y</code></h5><p>匹配 <code>x</code> 或 <code>y</code></p>
<p>例如，<code>/green|red/</code> 匹配 “green apple” 中的 ‘green’，”red apple.” 中的 ‘red’。</p>
<h5 id="x-n"><a href="#x-n" class="headerlink" title="x{n}"></a><code>x{n}</code></h5><p><code>n</code> 是一个正整数。前面的模式 <code>x</code> 连续出现 <code>n</code> 次时匹配。</p>
<p>例如，<code>/a{2}/</code> 不匹配 “candy,” 中的 “a”，但是匹配 “caandy,” 中的两个 “a”，且匹配 “caaandy.” 中的前两个 “a”。</p>
<h5 id="x-n-1"><a href="#x-n-1" class="headerlink" title="x{n,}"></a><code>x{n,}</code></h5><p><code>n</code> 是一个正整数。前面的模式 x 连续出现至少 n 次时匹配。</p>
<p>例如，<code>/a{2,}/</code> 不匹配 “candy” 中的 “a”，但是匹配 “caandy” 和 “caaaaaaandy.” 中所有的 “a”。</p>
<h5 id="x-n-m"><a href="#x-n-m" class="headerlink" title="x{n,m}"></a><code>x{n,m}</code></h5><p><code>n</code> 和 <code>m</code> 为正整数。前面的模式 x 连续出现至少 n 次，至多 m 次时匹配。</p>
<p>例如，<code>/a{1,3}/</code> 不匹配 “cndy”，匹配 “candy,” 中的 “a”，”caandy,” 中的两个 “a”，匹配 “caaaaaaandy” 中的前面三个 “a”。注意，当匹配 “caaaaaaandy” 时，即使原始字符串拥有更多的 “a”，匹配项也是 “aaa”。</p>
<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><h5 id="x-y-2"><a href="#x-y-2" class="headerlink" title="x(?=y)"></a><code>x(?=y)</code></h5><p>仅匹配被y跟随的x。</p>
<p>举个例子，<code>/Jack(?=Sprat)/</code>，如果”Jack”后面跟着sprat，则匹配之。</p>
<p><code>/Jack(?=Sprat|Frost)/</code> ，如果”Jack”后面跟着”Sprat”或者”Frost”，则匹配之。但是，”Sprat” 和”Frost” 都不会在匹配结果中出现。</p>
<h5 id="x-y-3"><a href="#x-y-3" class="headerlink" title="x(?!y)"></a><code>x(?!y)</code></h5><p>仅匹配不被y跟随的x。</p>
<p>举个例子，<code>/\d+(?!\.)/</code> 只会匹配不被点（.）跟随的数字。<br><code>/\d+(?!\.)/.exec(&#39;3.141&#39;)</code> 匹配”141”，而不是”3.141”</p>
]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
</search>
